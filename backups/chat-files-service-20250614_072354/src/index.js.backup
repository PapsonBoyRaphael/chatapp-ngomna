const dotenv = require('dotenv');
dotenv.config();

// Supprimer les warnings Kafka
process.env.KAFKAJS_NO_PARTITIONER_WARNING = '1';

const fastify = require('fastify')({
  logger:
    process.env.NODE_ENV === 'development'
      ? {
          transport: {
            target: 'pino-pretty',
            options: {
              colorize: true,
              translateTime: 'HH:MM:ss Z',
              ignore: 'pid,hostname',
            },
          },
        }
      : true,
  trustProxy: true,
  disableRequestLogging: false,
});

// Variable pour Ã©viter les double-initialisations
let isStarted = false;

async function start() {
  if (isStarted) {
    console.warn('Service already started, ignoring duplicate start attempt');
    return;
  }

  try {
    isStarted = true;

    // Charger la configuration aprÃ¨s l'initialisation de dotenv
    const config = require('./shared/config');
    const logger = require('./shared/utils/logger');

    logger.info('ðŸš€ Starting Chat-Files-Service...');

    // Register plugins
    await registerPlugins(config);
    logger.info('âœ… Plugins registered');

    // Connect to databases
    const connections = await initializeConnections(logger);

    // Register routes
    await registerRoutes(logger);
    logger.info('âœ… Routes registered');

    // Initialize WebSocket if available
    await initializeWebSocket(config, logger);

    // Start server
    const { port, host } = config.server;
    await fastify.listen({ port, host });

    // Log startup summary
    logStartupSummary(config, logger, connections);
  } catch (error) {
    isStarted = false;
    console.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
}

async function registerPlugins(config) {
  // CORS
  await fastify.register(require('@fastify/cors'), config.security.cors);

  // Security headers
  await fastify.register(require('@fastify/helmet'), {
    contentSecurityPolicy: false,
    crossOriginEmbedderPolicy: false,
  });

  // Compression
  await fastify.register(require('@fastify/compress'), {
    global: true,
  });

  // Servir les fichiers statiques
  await fastify.register(require('@fastify/static'), {
    root: require('path').join(__dirname, 'public'),
    prefix: '/public/', // Optionnel, pour servir avec /public/
  });

  // Multipart support for file uploads
  await fastify.register(require('@fastify/multipart'), {
    limits: {
      fileSize: config.fileStorage.maxFileSize,
      files: 5,
      fieldSize: 1024 * 1024,
    },
    addToBody: true,
  });

  // Rate limiting
  await fastify.register(require('@fastify/rate-limit'), {
    max: config.security.rateLimiting.max,
    timeWindow: config.security.rateLimiting.windowMs,
    errorResponseBuilder: function (request, context) {
      return {
        error: 'Too Many Requests',
        message: config.security.rateLimiting.message,
        statusCode: 429,
        retryAfter: Math.round(context.ttl / 1000),
      };
    },
  });
}

async function registerRoutes(logger) {
  // Routes principales avec prÃ©fixe API
  await fastify.register(require('./interfaces/http/routes'), {
    prefix: '/api/v1',
  });

  // Route de base pour vÃ©rifier que le service fonctionne
  fastify.get('/', async (request, reply) => {
    return {
      service: 'CENADI Chat-Files-Service',
      status: 'running',
      version: '1.0.0',
      timestamp: new Date().toISOString(),
      documentation: '/api/v1',
      health: '/api/v1/health',
      tester: '/tester', // ðŸ‘ˆ Nouveau lien vers le testeur
    };
  });

  // Route pour servir le testeur HTML directement
  fastify.get('/tester', async (request, reply) => {
    reply.type('text/html');
    const fs = require('fs');
    const path = require('path');

    try {
      const htmlPath = path.join(__dirname, 'public', 'chat-files-service-tester.html');
      const htmlContent = fs.readFileSync(htmlPath, 'utf8');
      return htmlContent;
    } catch (error) {
      reply.code(404);
      return {
        error: 'Testeur HTML non trouvÃ©',
        message: "Le fichier de test n'a pas Ã©tÃ© trouvÃ© dans src/public/",
        statusCode: 404,
      };
    }
  });

  // Handler global pour les erreurs
  fastify.setErrorHandler(async (error, request, reply) => {
    const statusCode = error.statusCode || 500;

    // Log l'erreur
    logger.error('Request error:', {
      error: error.message,
      stack: error.stack,
      url: request.url,
      method: request.method,
      statusCode,
    });

    // RÃ©ponse d'erreur standardisÃ©e
    reply.code(statusCode);
    return {
      error: error.name || 'Internal Server Error',
      message: statusCode === 500 ? 'An unexpected error occurred' : error.message,
      statusCode,
      timestamp: new Date().toISOString(),
    };
  });
}

async function initializeConnections(logger) {
  const connections = { MongoDB: false, Redis: false, Kafka: false };

  // MongoDB connection
  try {
    const mongoConnection = require('./infrastructure/database/mongodb/connection');
    await mongoConnection.connect();
    connections.MongoDB = true;
  } catch (error) {
    logger.warn('âš ï¸ MongoDB connection failed:', error.message);
  }

  // Redis connection
  try {
    const redisConnection = require('./infrastructure/database/redis/connection');
    await redisConnection.connect();
    connections.Redis = true;
  } catch (error) {
    logger.warn('âš ï¸ Redis connection failed:', error.message);
  }

  // Kafka connection (optionnel)
  const config = require('./shared/config');
  if (config.kafka.enabled) {
    try {
      const kafkaProducer = require('./infrastructure/messaging/kafka/KafkaProducer');
      await kafkaProducer.connect();
      connections.Kafka = true;
    } catch (error) {
      logger.warn('âš ï¸ Kafka connection failed:', error.message);
    }
  } else {
    logger.info('ðŸ”‡ Kafka disabled via configuration');
  }

  return connections;
}

async function initializeWebSocket(config, logger) {
  if (!config.websocket.enabled) {
    logger.info('ðŸ“¡ WebSocket disabled via configuration');
    return;
  }

  try {
    // VÃ©rifier si socket.io est disponible
    require.resolve('socket.io');

    const SocketIOServer = require('./interfaces/websocket/SocketIOServer');
    const io = new SocketIOServer(fastify.server);
    await io.initialize();
    logger.info('âœ… WebSocket server initialized');
  } catch (error) {
    if (error.code === 'MODULE_NOT_FOUND') {
      logger.info('ðŸ“¡ Socket.IO not installed, WebSocket disabled');
    } else {
      logger.warn('âš ï¸ WebSocket initialization failed:', error.message);
    }
  }
}

function logStartupSummary(config, logger, connections) {
  const { port, host } = config.server;

  logger.info(`ðŸŽ¯ Chat-Files-Service running on ${host}:${port}`);
  logger.info(`ðŸ“š API Documentation: http://${host}:${port}/api/v1`);
  logger.info(`ðŸ¥ Health check: http://${host}:${port}/api/v1/health`);

  // Status des connexions
  const connectionStatus = Object.entries(connections)
    .map(([service, connected]) => (connected ? `âœ… ${service}` : `âŒ ${service}`))
    .join(' | ');
  logger.info(`ðŸ”— Services: ${connectionStatus}`);

  // Configuration active
  logger.info(`âš™ï¸ Environment: ${config.server.environment}`);
  logger.info(`ðŸ“ Upload path: ${config.fileStorage.uploadPath}`);
  logger.info(`ðŸ“Š Max file size: ${Math.round(config.fileStorage.maxFileSize / 1024 / 1024)}MB`);
  logger.info(
    `ðŸ”’ Rate limit: ${config.security.rateLimiting.max} req/${config.security.rateLimiting.windowMs}ms`
  );
}

// Graceful shutdown
const gracefulShutdown = async () => {
  console.log('ðŸ”„ Shutting down gracefully...');
  try {
    await fastify.close();

    // Fermer les connexions aux bases de donnÃ©es
    try {
      const mongoConnection = require('./infrastructure/database/mongodb/connection');
      await mongoConnection.disconnect();
    } catch (error) {
      console.warn('MongoDB disconnect warning:', error.message);
    }

    try {
      const redisConnection = require('./infrastructure/database/redis/connection');
      await redisConnection.disconnect();
    } catch (error) {
      console.warn('Redis disconnect warning:', error.message);
    }

    console.log('âœ… Server closed successfully');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error during shutdown:', error);
    process.exit(1);
  }
};

// Gestion des signaux systÃ¨me
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// DÃ©marrer le service
start();
